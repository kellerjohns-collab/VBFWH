// -*- C++ -*-
#include "Rivet/Analysis.hh"
#include "Rivet/Projections/FinalState.hh"
#include "Rivet/Projections/FastJets.hh"
#include "Rivet/Projections/DressedLeptons.hh"
#include "Rivet/Projections/MissingMomentum.hh"
#include "Rivet/Projections/PromptFinalState.hh"
#include "Rivet/Projections/VetoedFinalState.hh"
#include "TFile.h"
#include "./OutputTree.h"

//Analysis code for VBF_WH processes generated by Madgraph

//OutputTree.h should be in the pwd or else change the path in the include line above
//The OutputTree.h file can be found at 
// https://gitlab.cern.ch/carleton-ATLAS/hadron-level-jet-classification/-/blob/master/plotMacros/OutputTree.h

namespace Rivet {


  /// @brief Add a short analysis description here
  class VBF_WHplots : public Analysis {
  public:

    /// Constructor
    DEFAULT_RIVET_ANALYSIS_CTOR(VBF_WHplots);


    /// @name Analysis methods
    //@{
    /// Book histograms and initialise projections before the run
    void init() {

      // Initialise and register projections

      // The basic final-state projection:
      // all final-state particles within
      // the given eta acceptance
      const FinalState fs(Cuts::abseta < 4.9);

      // FinalState of prompt photons and bare muons and electrons in the event
      PromptFinalState photons(Cuts::abspid == PID::PHOTON);
      PromptFinalState bare_els(Cuts::abspid == PID::ELECTRON);
      PromptFinalState bare_mus(Cuts::abspid == PID::MUON);

      // Dress the prompt bare leptons with prompt photons within dR < 0.1,
      // and apply some fiducial cuts on the dressed leptons
      Cut lepton_cuts = Cuts::abseta < 2.5 && Cuts::pT > 10*GeV; 
      DressedLeptons dressed_els(photons, bare_els, 0.1, lepton_cuts);
      DressedLeptons dressed_mus(photons, bare_mus, 0.1, lepton_cuts);
      declare(dressed_els, "electrons");
      declare(dressed_mus, "muons");


      // Define jets in the "WZTruth" style
      VetoedFinalState vfs(FinalState(Cuts::abseta < 4.5));
      vfs.addVetoOnThisFinalState(dressed_els);
      vfs.addVetoOnThisFinalState(dressed_mus);
      FastJets jets(vfs, FastJets::ANTIKT, 0.4, JetAlg::Muons::ALL, JetAlg::Invisibles::NONE);
      declare(jets, "jets");


      // Missing momentum
      declare(MissingMomentum(fs), "MET");

      // Book histograms
      // specify custom binning
      book(_h["BJet1Pt"], "BJet1Pt", 100, 0.0, 500.0);
      book(_h["BJet2Pt"], "BJet2Pt", 60, 0.0, 300.0);
      book(_h["BJetMaxEta"], "BJetMaxEta", 60, 0.0, 3.0);
      book(_h["nBJets"], "nBJets", 6, -0.5, 5.5);
      book(_h["nLeptons"], "nLeptons", 3, -0.5, 2.5);
      book(_h["LepPt_presel"], "LepPt_presel", 100, 0.0, 400.0);
      book(_h["LepPt"], "LepPt", 100, 0.0, 500.0);
      book(_h["LepCharge"], "LepCharge", 3, -1.5, 1.5);
      book(_h["MET"], "MET", 100, 0.0, 500.0);
      book(_h["pTW_presel"], "pTW_presel", 100, 0.0, 600.0);
      book(_h["pTW"], "pTW", 53, 70.0, 600.0);
      book(_h["pTbb"],"pTbb", 100, 0.0, 250.0);
      book(_h["mbb"],"mbb", 60, 0.0, 600.0);
      book(_h["drbb"],"drbb",100,0.0, 5.0);
      book(_h["VBFcands"],"VBFcands",11,-0.5,10.5);
      book(_h["mjj"],"mjj",100,0.0,4000.0);
      book(_h["mLepTop"],"mLepTop",80,0.0,800.0);
      book(_h["detajj"],"detajj",90,0.0,9.0);
      book(_h["nVeto25"],"nVeto25",5,-0.5,4.5);
      book(_h["nVeto30"],"nVeto30",5,-0.5,4.5);
      book(_h["nVeto40"],"nVeto40",5,-0.5,4.5);
      book(_h["nVeto50"],"nVeto50",5,-0.5,4.5);
      book(_h["VBFjet1Pt"],"VBFjet1Pt",70,0.0,700.0);
      book(_h["VBFjet2Pt"],"VBFjet2Pt",60,0.0,300.0);
      book(_h["centrality_H"],"centrality_H",100,0.0,4.0);
      book(_h["centrality_HW"],"centrality_HW",100,0.0,4.0);
      book(_h["dphi_jj_HW"], "dphi_jj_HW",100,0.0,3.15);

      book(_h["BJet1Pt_SRLoose"], "BJet1Pt_SRLoose", 100, 0.0, 500.0);
      book(_h["BJet2Pt_SRLoose"], "BJet2Pt_SRLoose", 60, 0.0, 300.0);
      book(_h["LepPt_SRLoose"], "LepPt_SRLoose", 100, 0.0, 500.0);
      book(_h["MET_SRLoose"], "MET_SRLoose", 100, 0.0, 500.0);
      book(_h["pTW_SRLoose"], "pTW_SRLoose", 53, 70.0, 600.0);
      book(_h["pTbb_SRLoose"],"pTbb_SRLoose", 100, 0.0, 250.0);
      book(_h["mbb_SRLoose"],"mbb_SRLoose", 60, 0.0, 600.0);
      book(_h["drbb_SRLoose"],"drbb_SRLoose", 100,0.0, 5.0);
      book(_h["VBFcands_SRLoose"],"VBFcands_SRLoose", 11,-0.5,10.5);
      book(_h["mjj_SRLoose"],"mjj_SRLoose", 100,0.0,4000.0);
      book(_h["mLepTop_SRLoose"],"mLepTop_SRLoose", 80,0.0,800.0);
      book(_h["detajj_SRLoose"],"detajj_SRLoose", 90,0.0,9.0);
      book(_h["nVeto25_SRLoose"],"nVeto25_SRLoose", 5,-0.5,4.5);
      book(_h["nVeto30_SRLoose"],"nVeto30_SRLoose", 5,-0.5,4.5);
      book(_h["nVeto40_SRLoose"],"nVeto40_SRLoose", 5,-0.5,4.5);
      book(_h["nVeto50_SRLoose"],"nVeto50_SRLoose", 5,-0.5,4.5);
      book(_h["VBFjet1Pt_SRLoose"],"VBFjet1Pt_SRLoose", 70,0.0,700.0);
      book(_h["VBFjet2Pt_SRLoose"],"VBFjet2Pt_SRLoose", 60,0.0,300.0);
      book(_h["centrality_HW_SRLoose"],"centrality_HW_SRLoose", 100,0.0,4.0);
      book(_h["dphi_jj_HW_SRLoose"], "dphi_jj_HW_SRLoose", 100,0.0,3.15);

      book(_h["BJet1Pt_SRTight"], "BJet1Pt_SRTight", 100, 0.0, 500.0);
      book(_h["BJet2Pt_SRTight"], "BJet2Pt_SRTight", 60, 0.0, 300.0);
      book(_h["LepPt_SRTight"], "LepPt_SRTight", 100, 0.0, 500.0);
      book(_h["MET_SRTight"], "MET_SRTight", 100, 0.0, 500.0);
      book(_h["pTW_SRTight"], "pTW_SRTight", 53, 70.0, 600.0);
      book(_h["pTbb_SRTight"],"pTbb_SRTight", 100, 0.0, 250.0);
      book(_h["mbb_SRTight"],"mbb_SRTight", 60, 0.0, 600.0);
      book(_h["drbb_SRTight"],"drbb_SRTight", 100,0.0, 5.0);
      book(_h["VBFcands_SRTight"],"VBFcands_SRTight", 11,-0.5,10.5);
      book(_h["mjj_SRTight"],"mjj_SRTight", 100,0.0,4000.0);
      book(_h["mLepTop_SRTight"],"mLepTop_SRTight", 80,0.0,800.0);
      book(_h["detajj_SRTight"],"detajj_SRTight", 90,0.0,9.0);
      book(_h["nVeto25_SRTight"],"nVeto25_SRTight", 5,-0.5,4.5);
      book(_h["nVeto30_SRTight"],"nVeto30_SRTight", 5,-0.5,4.5);
      book(_h["nVeto40_SRTight"],"nVeto40_SRTight", 5,-0.5,4.5);
      book(_h["nVeto50_SRTight"],"nVeto50_SRTight", 5,-0.5,4.5);
      book(_h["VBFjet1Pt_SRTight"],"VBFjet1Pt_SRTight", 70,0.0,700.0);
      book(_h["VBFjet2Pt_SRTight"],"VBFjet2Pt_SRTight", 60,0.0,300.0);
      book(_h["centrality_HW_SRTight"],"centrality_HW_SRTight", 100,0.0,4.0);
      book(_h["dphi_jj_HW_SRTight"], "dphi_jj_HW_SRTight", 100,0.0,3.15);


      book(_h["BJet1Pt_SRNeg"], "BJet1Pt_SRNeg", 100, 0.0, 500.0);
      book(_h["BJet2Pt_SRNeg"], "BJet2Pt_SRNeg", 60, 0.0, 300.0);
      book(_h["LepPt_SRNeg"], "LepPt_SRNeg", 100, 0.0, 500.0);
      book(_h["MET_SRNeg"], "MET_SRNeg", 100, 0.0, 500.0);
      book(_h["pTW_SRNeg"], "pTW_SRNeg", 53, 70.0, 600.0);
      book(_h["pTbb_SRNeg"],"pTbb_SRNeg", 100, 0.0, 250.0);
      book(_h["mbb_SRNeg"],"mbb_SRNeg", 60, 0.0, 600.0);
      book(_h["drbb_SRNeg"],"drbb_SRNeg", 100,0.0, 5.0);
      book(_h["VBFcands_SRNeg"],"VBFcands_SRNeg", 11,-0.5,10.5);
      book(_h["mjj_SRNeg"],"mjj_SRNeg", 100,0.0,4000.0);
      book(_h["mLepTop_SRNeg"],"mLepTop_SRNeg", 80,0.0,800.0);
      book(_h["detajj_SRNeg"],"detajj_SRNeg", 90,0.0,9.0);
      book(_h["nVeto25_SRNeg"],"nVeto25_SRNeg", 5,-0.5,4.5);
      book(_h["nVeto30_SRNeg"],"nVeto30_SRNeg", 5,-0.5,4.5);
      book(_h["nVeto40_SRNeg"],"nVeto40_SRNeg", 5,-0.5,4.5);
      book(_h["nVeto50_SRNeg"],"nVeto50_SRNeg", 5,-0.5,4.5);
      book(_h["VBFjet1Pt_SRNeg"],"VBFjet1Pt_SRNeg", 70,0.0,700.0);
      book(_h["VBFjet2Pt_SRNeg"],"VBFjet2Pt_SRNeg", 60,0.0,300.0);
      book(_h["centrality_HW_SRNeg"],"centrality_HW_SRNeg", 100,0.0,4.0);
      book(_h["dphi_jj_HW_SRNeg"], "dphi_jj_HW_SRNeg", 100,0.0,3.15);


      // output tree to be saved in root file
      otree.create("VBF_WHtree");
      otree.createFBranches({"m_bb","pT_W","m_jj","detajj","pT_bb","dR_bb","pT_b1","pT_b2","eta_b1","eta_b2","phi_b1","phi_b2","m_b1","m_b2","pT_vbfj1","pT_vbfj2","eta_vbfj1","eta_vbfj2","phi_vbfj1","phi_vbfj2","m_vbfj1","m_vbfj2","MET","METphi","pT_lep","eta_lep","phi_lep","pT_Wjj","phi_HW","phi_jj"});
      otree.createIBranches({"nVetoJets30","nVetoJets40","nVetoJets50","lep_pdgid"});

    }


    /// Perform the per-event analysis
    void analyze(const Event& event) {

      // Reset the values of the output tree
      otree.resetBranches();

      // Retrieve dressed leptons, sorted by pT
      vector<DressedLepton> electrons = apply<DressedLeptons>(event, "electrons").dressedLeptons();
      vector<DressedLepton> muons = apply<DressedLeptons>(event, "muons").dressedLeptons();

      // Retrieve clustered jets, sorted by pT, with a minimum pT cut
      Jets jets = apply<FastJets>(event, "jets").jetsByPt(Cuts::pT > 20*GeV && Cuts::abseta < 4.5);

      // Remove all jets within dR < 0.2 of a dressed electron
      //idiscardIfAnyDeltaRLess(jets, electrons, 0.2);

      // Discard jets low-ntrk jets close to muons or electrons. Take this out now htat we're excluding prompt leponts from jets.
      // const Jets isojets = filter_select(jets, [&](const Jet& j) {
      // 	  if (j.particles(Cuts::abscharge > 0 && Cuts::pT > 0.4*GeV).size() < 3 && any(muons, deltaRLess(j, 0.4))) return false;
      // 	  if (j.particles(Cuts::abscharge > 0 && Cuts::pT > 0.4*GeV).size() < 3 && any(electrons, deltaRLess(j, 0.4))) return false;
      // 	  return true;
      // 	});

      // Select jets ghost-associated to B-hadrons with a certain fiducial selection
      Jets bjets = filter_select(jets, [](const Jet& jet) {
	  return  jet.bTagged(Cuts::pT > 5*GeV && Cuts::abseta < 2.5);
	});
      
      
      //count total events
      ++N_all;

      //Event selection: leptons
      _h["nLeptons"]->fill( electrons.size() + muons.size() );
      if( electrons.size() + muons.size() != 1 ) return;
      Particle lep;
      if(electrons.size() == 1) lep = electrons[0];
      if(muons.size() == 1) lep = muons[0];
      _h["LepPt_presel"]->fill(lep.pt()/GeV);
      if(lep.pt() < 27*GeV) return;
      ++N_lep_pT_cut;
      
      //Event selection: exactly 2 b-jets
      _h["nBJets"]->fill(bjets.size());
      if( bjets.size() != 2 ) return;
      ++N_2BJets;

      //Event selection: pT W. Note that we want MPT and not MET I think
      FourMomentum lep4v = lep.momentum();
      MissingMomentum met = apply<MissingMomentum>(event, "MET");
      Vector3 metvec = met.vectorMPT();
      FourMomentum met4v; //assume neutrino and lepton have same eta
      met4v.setThetaPhiMPt(lep.theta(), metvec.phi(), 0, metvec.perp() );
      FourMomentum W4v = lep4v + met4v;

      // Get VBF candidadate jets: 30 GeV, not b-tagged
      Jets VBFcands = filter_select(jets, [](const Jet& jet) {
	  if( jet.bTagged(Cuts::pT > 5*GeV && Cuts::abseta < 2.5) ) return false;
	  return (jet.pT() > 30*GeV);
	});
      _h["VBFcands"]->fill( VBFcands.size() );
      if(VBFcands.size() < 2) return;
      ++N_2VBF;

      //Choose the vbf jets
      Jet* vj1 = new Jet();
      Jet* vj2 = new Jet();

      //old style: max mjj
      // float maxmjj = 0.;
      // for(unsigned int j = 0; j < VBFcands.size()-1; j++){
      // 	for(unsigned int jj = j+1; jj < VBFcands.size(); jj++){
      // 	  auto j1 = VBFcands[j].momentum();
      // 	  auto j2 = VBFcands[jj].momentum();
      // 	  auto jpair = j1.operator+=(j2);
      // 	  if( jpair.mass() > maxmjj ){
      // 	    vj1 = &VBFcands.at(j);
      // 	    vj2 = &VBFcands.at(jj);
      // 	    maxmjj = jpair.mass();
      // 	  }
      // 	}
      // }

      //jk check that this is correctly ordered
      vj1 = &VBFcands[0];
      vj2 = &VBFcands[1];
      if(vj2->pt() > vj1->pt()) cout<<"jk mis ordered!"<<endl;

      auto vj1m = vj1->momentum();
      auto vj2m = vj2->momentum();
      auto vjj = vj1m + vj2m;


      float detajj = fabs(vj1->eta() - vj2->eta());
      float mjj = vjj.mass();

      //Fill other variables
      _h["mjj"]->fill(mjj);
      _h["detajj"]->fill(detajj);
      _h["MET"]->fill(metvec.perp());
      _h["LepPt"]->fill(lep.pt()/GeV);
      _h["LepCharge"]->fill(lep.charge());
      float pTW = W4v.pt();
      _h["pTW"]->fill( pTW );
      _h["VBFjet1Pt"]->fill(vj1->pt());
      _h["VBFjet2Pt"]->fill(vj2->pt());

      otree.floats["pT_vbfj1"] = vj1->pt();
      otree.floats["pT_vbfj2"] = vj2->pt();
      otree.floats["eta_vbfj1"] = vj1->eta();
      otree.floats["eta_vbfj2"] = vj2->eta();
      otree.floats["phi_vbfj1"] = vj1->phi();
      otree.floats["phi_vbfj2"] = vj2->phi();
      otree.floats["m_vbfj1"] = vj1->mass();
      otree.floats["m_vbfj2"] = vj2->mass();
      otree.floats["m_jj"] = mjj;
      otree.floats["detajj"] = detajj;
      otree.floats["pT_W"] = pTW;
      otree.floats["MET"] = metvec.perp();
      otree.floats["METphi"] = metvec.phi();
      otree.floats["pT_lep"] = lep.pt();
      otree.floats["eta_lep"] = lep.eta();
      otree.floats["phi_lep"] = lep.phi();
      if(electrons.size() == 1 && lep.charge() > 0) otree.ints["lep_pdgid"] = 11;
      if(electrons.size() == 1 && lep.charge() < 0) otree.ints["lep_pdgid"] = -11;
      if(electrons.size() == 0 && lep.charge() > 0) otree.ints["lep_pdgid"] = 13;
      if(electrons.size() == 0 && lep.charge() < 0) otree.ints["lep_pdgid"] = -13;

      
      //histogram the kinematics of the b-jets
      _h["BJet1Pt"]->fill(bjets[0].pT()/GeV);      
      _h["BJet2Pt"]->fill(bjets[1].pT()/GeV);
      auto b1 = bjets[0].momentum();
      auto b2 = bjets[1].momentum();
      float bbDR = Rivet::deltaR(b1, b2);
      _h["drbb"]->fill(bbDR);
      if(fabs(b1.eta()) > fabs(b2.eta())) _h["BJetMaxEta"]->fill(fabs(b1.eta()));
      else _h["BJetMaxEta"]->fill(fabs(b2.eta()));
      otree.floats["pT_b1"] = b1.pT();
      otree.floats["pT_b2"] = b2.pT();
      otree.floats["eta_b1"] = b1.eta();
      otree.floats["eta_b2"] = b2.eta();
      otree.floats["phi_b1"] = b1.phi();
      otree.floats["phi_b2"] = b2.phi();
      otree.floats["m_b1"] = b1.mass();
      otree.floats["m_b2"] = b2.mass();
      auto bb = b1.operator+=(b2);
      float bbMass = bb.mass();
      float bbpT = bb.pT();
      _h["pTbb"]->fill(bbpT);
      _h["mbb"]->fill(bbMass);
      otree.floats["dR_bb"] = bbDR;
      otree.floats["m_bb"] = bbMass;
      otree.floats["pT_bb"] = bbpT;

      //Check for veto jets
      int nv25 = 0;
      int nv30 = 0;
      int nv40 = 0; 
      int nv50 = 0;
      for(unsigned int j = 0; j < VBFcands.size(); j++){
	if(VBFcands[j].eta() == vj1->eta()) continue;
	if(VBFcands[j].eta() == vj2->eta()) continue;
	if(fabs(VBFcands[j].eta()) > 2.5) continue;
	if(VBFcands[j].pT() > 25) nv25++;
	if(VBFcands[j].pT() > 30) nv30++;
	if(VBFcands[j].pT() > 40) nv40++;
	if(VBFcands[j].pT() > 50) nv50++;
      }
      _h["nVeto25"]->fill(nv25);
      _h["nVeto30"]->fill(nv30);
      _h["nVeto40"]->fill(nv40);
      _h["nVeto50"]->fill(nv50);
      otree.ints["nVetoJets30"] = nv30;
      otree.ints["nVetoJets40"] = nv40;
      otree.ints["nVetoJets50"] = nv50;
      

      //Centrality
      //(ybb - yjj)/Dyjj
      float y_bb = bb.rapidity();
      auto vecHW = bb + W4v;
      float y_HW = vecHW.rapidity();
      float y_jj = vjj.rapidity();
      float dyjj = fabs( vj1->momentum().rapidity() - vj2->momentum().rapidity() );
      float centralityH = fabs(y_bb - y_jj)/dyjj;
      float centralityHW = fabs(y_HW - y_jj)/dyjj;
      _h["centrality_H"]->fill(centralityH);
      _h["centrality_HW"]->fill(centralityHW);    
      
      //a few more things
      auto vecWjj = W4v + vjj;
      otree.floats["pT_Wjj"] = vecWjj.pt();
      otree.floats["phi_HW"] = vecHW.phi();
      otree.floats["phi_jj"] = vjj.phi();
      _h["dphi_jj_HW"]->fill( Rivet::deltaPhi( vjj, vecHW ) );

      auto mt1 = (W4v + b1).mass();
      auto mt2 = (W4v + b2).mass();
      float mLepTop = mt1;
      if( fabs(mt1 - 172.7) > fabs(mt2 - 172.7) ) mLepTop = mt2;
      _h["mLepTop"]->fill(mLepTop);


      //N Veto jets in pos signal regions.
      bool PassSRL = (detajj > 3.) && (mjj > 600.) && (bbDR < 1.6) && (bbpT > 100.) && (mLepTop > 260.) && (bbMass > 105.) && (bbMass < 145.) && (centralityHW < 0.3);
      bool PassSRT = (detajj > 3.) && (mjj > 1000.) && (bbDR < 1.2) && (bbpT > 180.) && (mLepTop > 260.) && (bbMass > 105.) && (bbMass < 145.) && (centralityHW < 0.3) && (Rivet::deltaPhi( vjj, vecHW ) > 2.7);
      bool PassSRN = (detajj > 4.4) && (bbDR < 1.2) && (bbpT > 250.) && (mLepTop > 260.) && (bbMass > 105.) && (bbMass < 145.) && (centralityHW < 0.3);

      if(PassSRL){
	_h["nVeto25_SRLoose"]->fill(nv25);
	if(nv25 < 2){
	  _h["mjj_SRLoose"]->fill(mjj);
          _h["detajj_SRLoose"]->fill(detajj);
          _h["MET_SRLoose"]->fill(metvec.perp());
          _h["LepPt_SRLoose"]->fill(lep.pt()/GeV);
          _h["pTW_SRLoose"]->fill( pTW );
          _h["VBFjet1Pt_SRLoose"]->fill(vj1->pt());
          _h["VBFjet2Pt_SRLoose"]->fill(vj2->pt());
          _h["nVeto30_SRLoose"]->fill(nv30);
          _h["nVeto40_SRLoose"]->fill(nv40);
          _h["nVeto50_SRLoose"]->fill(nv50);
          _h["centrality_HW_SRLoose"]->fill(centralityHW);    
          _h["mLepTop_SRLoose"]->fill(mLepTop);
          _h["BJet1Pt_SRLoose"]->fill(bjets[0].pT()/GeV);      
          _h["BJet2Pt_SRLoose"]->fill(bjets[1].pT()/GeV);
          _h["drbb_SRLoose"]->fill(bbDR);
          _h["pTbb_SRLoose"]->fill(bbpT);
          _h["mbb_SRLoose"]->fill(bbMass);
	}
      }

      if(PassSRT){
	_h["nVeto25_SRTight"]->fill(nv25);
	if(nv25 < 1){
	  _h["mjj_SRTight"]->fill(mjj);
          _h["detajj_SRTight"]->fill(detajj);
          _h["MET_SRTight"]->fill(metvec.perp());
          _h["LepPt_SRTight"]->fill(lep.pt()/GeV);
          _h["pTW_SRTight"]->fill( pTW );
          _h["VBFjet1Pt_SRTight"]->fill(vj1->pt());
          _h["VBFjet2Pt_SRTight"]->fill(vj2->pt());
          _h["nVeto30_SRTight"]->fill(nv30);
          _h["nVeto40_SRTight"]->fill(nv40);
          _h["nVeto50_SRTight"]->fill(nv50);
          _h["centrality_HW_SRTight"]->fill(centralityHW);    
          _h["mLepTop_SRTight"]->fill(mLepTop);
          _h["BJet1Pt_SRTight"]->fill(bjets[0].pT()/GeV);      
          _h["BJet2Pt_SRTight"]->fill(bjets[1].pT()/GeV);
          _h["drbb_SRTight"]->fill(bbDR);
          _h["pTbb_SRTight"]->fill(bbpT);
          _h["mbb_SRTight"]->fill(bbMass);
	}
      }

      if(PassSRN){
	_h["nVeto25_SRNeg"]->fill(nv25);
	_h["mjj_SRNeg"]->fill(mjj);
        _h["detajj_SRNeg"]->fill(detajj);
        _h["MET_SRNeg"]->fill(metvec.perp());
        _h["LepPt_SRNeg"]->fill(lep.pt()/GeV);
        _h["pTW_SRNeg"]->fill( pTW );
        _h["VBFjet1Pt_SRNeg"]->fill(vj1->pt());
        _h["VBFjet2Pt_SRNeg"]->fill(vj2->pt());
        _h["nVeto30_SRNeg"]->fill(nv30);
        _h["nVeto40_SRNeg"]->fill(nv40);
        _h["nVeto50_SRNeg"]->fill(nv50);
        _h["centrality_HW_SRNeg"]->fill(centralityHW);    
        _h["mLepTop_SRNeg"]->fill(mLepTop);
        _h["BJet1Pt_SRNeg"]->fill(bjets[0].pT()/GeV);      
        _h["BJet2Pt_SRNeg"]->fill(bjets[1].pT()/GeV);
        _h["drbb_SRNeg"]->fill(bbDR);
        _h["pTbb_SRNeg"]->fill(bbpT);
        _h["mbb_SRNeg"]->fill(bbMass);
      }



      // add to the output tree
      otree.fill();


      //neg cutflow
      if(detajj > 4.4){
	N_deta44++;
	if(bbpT > 250.){
	  N_bbpt250++;
	  if(bbDR < 1.2){
	    N_bbdr12n++;
	    if(mLepTop > 260.){
	      N_mLepTop260n++;
	      if(centralityHW < 0.3){
		N_centrality03n++;
		if(bbMass > 105. && bbMass < 145.){
		  N_massWindown++;
		}
	      }
	    }
	  }
	}
      }


      //Do some more selection
      if(detajj < 3.) return;
      N_deta3++;
      if(mjj < 600.) return;
      N_mjj600++;
      if(bbDR > 1.6) return;
      N_bbdr16++;
      if(bbpT < 100.) return;
      N_bbpt100++;
      if(mLepTop < 260.) return;
      N_mLepTop260++;
      if(centralityHW > 0.3) return;
      N_centrality03++;
      if(bbMass < 105. || bbMass > 145.) return;
      N_massWindow++;
      if(nv25 > 1) return;
      N_JetVeto1++;
      if(mjj < 1000.) return;
      N_mjj1000++;
      if(bbDR > 1.2) return;
      N_bbdr12++;
      if(bbpT < 180.) return;
      N_bbpt180++;
      if(Rivet::deltaPhi( vjj, vecHW ) < 2.7) return;
      N_dphi27++;
      if(nv25 > 0) return;
      N_JetVeto0++;


    }
    

    /// Normalise histograms etc., after the run
    void finalize() {

      // normalize(_h["BJet1Pt"]); // normalize to unity
      // normalize(_h["BJet2Pt"]);
      // normalize(_h["BJetMaxEta"]);
      // normalize(_h["nBJets"]);
      // normalize(_h["nLeptons"]);
      // normalize(_h["LepPt"]);
      // normalize(_h["LepPt_presel"]);
      // normalize(_h["LepCharge"]);
      // normalize(_h["MET"]);
      // normalize(_h["pTW"]);
      // normalize(_h["pTbb"]);
      // normalize(_h["mbb"]);
      // normalize(_h["drbb"]);
      // normalize(_h["VBFcands"]);
      // normalize(_h["mjj"]);
      // normalize(_h["detajj"]);
      // normalize(_h["nVeto25"]);
      // normalize(_h["nVeto25_SRLoose"]);
      // normalize(_h["nVeto25_SRTight"]);
      // normalize(_h["nVeto30"]);
      // normalize(_h["nVeto40"]);
      // normalize(_h["nVeto50"]);
      // normalize(_h["VBFjet1Pt"]);
      // normalize(_h["VBFjet2Pt"]);
      // normalize(_h["centrality_H"]);
      // normalize(_h["centrality_HW"]);
      // normalize(_h["dphi_jj_HW"]);


      //output some user readable numbers describing the cutflow
      //This emulates pos lambda cutflow
      cout << endl;
      cout << "Total Events:            " << N_all << endl;
      cout << "1 lep:                   " << N_lep_pT_cut << endl;
      cout << "2 b-jets:                " << N_2BJets << endl;
      cout << "2 VBF cands:             " << N_2VBF << endl;
      cout << "deta jj > 4.4:           " << N_deta44 << endl;
      cout << "pT(bb) > 250 GeV:        " << N_bbpt250 << endl;
      cout << "DR(bb) < 1.2:            " << N_bbdr12n << endl;
      cout << "mLepTop > 260 GeV:       " << N_mLepTop260n << endl;
      cout << "Centrality < 0.3:        " << N_centrality03n << endl;
      cout << "105 < mbb < 145:         " << N_massWindown << endl;


      cout << endl;
      cout << "Total Events:            " << N_all << endl;
      cout << "1 lep:                   " << N_lep_pT_cut << endl;
      cout << "2 b-jets:                " << N_2BJets << endl;
      cout << "2 VBF cands:             " << N_2VBF << endl;
      cout << "deta jj > 3.0:           " << N_deta3 << endl;
      cout << "mjj > 600 GeV:           " << N_mjj600 << endl;
      cout << "DR(bb) < 1.6:            " << N_bbdr16 << endl;
      cout << "pT(bb) > 100 GeV:        " << N_bbpt100 << endl;
      cout << "mLepTop > 260 GeV:       " << N_mLepTop260 << endl;
      cout << "Centrality < 0.3:        " << N_centrality03 << endl;
      cout << "105 < mbb < 145:         " << N_massWindow << endl;
      cout << "N veto jets < 2:         " << N_JetVeto1 << endl;
      cout << "mjj > 1000 GeV:          " << N_mjj1000 << endl;
      cout << "DR(bb) < 1.2:            " << N_bbdr12 << endl;
      cout << "pT(bb) > 180 GeV:        " << N_bbpt180 << endl;
      cout << "dphi(HW, jj) > 2.7:      " << N_dphi27 <<endl;
      cout << "N veto jets < 0:         " << N_JetVeto0 << endl;


      //cd to the TFile and write the TTree
      // rFile->cd();
      // otree.tree()->Write();
      // rFile->Close();
      
    }

    //@}


    /// @name Histograms
    //@{
    map<string, Histo1DPtr> _h;
    // map<string, Profile1DPtr> _p;
    // map<string, CounterPtr> _c;
    //@}
    
    OutputTree otree;
    TFile* rFile = new TFile("VBF_WH_events.root","RECREATE");

    int N_all = 0;
    int N_2BJets = 0;
    int N_lep_pT_cut = 0;
    int N_2VBF = 0;
    int N_deta3 = 0;
    int N_mjj600 = 0;
    int N_bbdr16 = 0;
    int N_bbpt100 = 0;
    int N_mLepTop260 = 0;
    int N_centrality03 = 0;
    int N_massWindow = 0;
    int N_JetVeto1 = 0;
    int N_mjj1000 = 0;
    int N_bbdr12 = 0;
    int N_bbpt180 = 0;
    int N_dphi27 = 0;
    int N_JetVeto0 = 0;

    int N_deta44 = 0;
    int N_bbpt250 = 0;
    int N_bbdr12n = 0;
    int N_mLepTop260n = 0;
    int N_centrality03n = 0; 
    int N_massWindown = 0;

    float sumw = 0.;
    float sumw2 = 0.;

  };


  DECLARE_RIVET_PLUGIN(VBF_WHplots);

}
